
// MFC4View.cpp : implementation of the CMFC4View class
//

#include "stdafx.h"
// SHARED_HANDLERS can be defined in an ATL project implementing preview, thumbnail
// and search filter handlers and allows sharing of document code with that project.
#ifndef SHARED_HANDLERS
#include "MFC4.h"
#endif

#include "MFC4Doc.h"
#include "MFC4View.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


// CMFC4View

IMPLEMENT_DYNCREATE(CMFC4View, CView)

BEGIN_MESSAGE_MAP(CMFC4View, CView)
	// Standard printing commands
	ON_COMMAND(ID_FILE_PRINT, &CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_DIRECT, &CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, &CView::OnFilePrintPreview)
END_MESSAGE_MAP()

// CMFC4View construction/destruction

CMFC4View::CMFC4View() noexcept
{
	// TODO: add construction code here

}

CMFC4View::~CMFC4View()
{
}

BOOL CMFC4View::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CView::PreCreateWindow(cs);
}
// inline functios
inline int CMFC4View::cx(double x)
{
	return (int)((x - xmin)*hf + 0.5);
}
inline int CMFC4View::cy(double y)
{

	return YUmax - (int)((y - ymin)*vf + 0.5);
}

// CMFC4View drawing

void CMFC4View::OnDraw(CDC* pDC)
{
	CMFC4Doc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);
	if (!pDoc)
		return;

	// TODO: add draw code for native data here
	int sx, sy, Xmax, Ymax;
	//  setting mapping mode
	pDC->SetMapMode(MM_TEXT);
	//
	Xmax = ::GetSystemMetrics(SM_CXSCREEN);
	Ymax = ::GetSystemMetrics(SM_CYSCREEN);
	//    
	sx = Xmax / 8, sy = Ymax / 11; // displace origin values 
//
	CString text("Hello Windows!");
	pDC->SetViewportOrg(sx, sy); // maps to (0,0)

	pDC->TextOut(-20, -20, text);
	//  
	XUmax = Xmax / 2, YUmax = Ymax / 2;

	//  setting  the logical plotting area    
	pDC->Rectangle(0, 0, XUmax, YUmax);

	const int sz = 100;
	int i, x, y; double PI = atan(1.0)*4.0;
	double X[sz], Y[sz], x0 = -PI, xN = PI, h;
	xmin = x0, xmax = xN, h = (xmax - xmin) / (sz - 1);
	for (i = 0; i < sz; ++i)
	{
		X[i] = x0 + i * h;
		//Y[i] = cos(X[i]);  
		Y[i] = 1.0/cos(X[i]);
	}
	ymax = Y[0], ymin = Y[0];
	for (i = 0; i < sz; ++i)
	{
		ymax = max(ymax, Y[i]);
		ymin = min(ymin, Y[i]);
	}
	hf = XUmax / (xmax - xmin), vf = YUmax / (ymax - ymin);
	// setting the physical plotting area    
	pDC->Rectangle(cx(xmin), cy(ymin), cx(xmax), cy(ymax));
	CPen RedPen(PS_SOLID, 1, RGB(255, 0, 0)); // red pen selected
	pDC->SelectObject(&RedPen);
	//  graph plot    
	for (i = 0; i < sz - 1; ++i)
	{
		pDC->MoveTo(cx(X[i]), cy(Y[i]));
		pDC->LineTo(cx(X[i + 1]), cy(Y[i + 1]));
	}
	CPen BluePen(PS_SOLID, 1, RGB(0, 0, 255));
	pDC->SelectObject(&BluePen); // blue pen selected 	  
// drawning axis of coordinates
	if (xmin <= 0.0)
	{
		// Y axis   
		pDC->MoveTo(cx(0.0), cy(ymin));
		pDC->LineTo(cx(0.0), cy(ymax));
		// X axis
		pDC->MoveTo(cx(xmin), cy(0.0));
		pDC->LineTo(cx(xmax), cy(0.0));
	}
	else
	{
		// Y axis not needed

		pDC->MoveTo(cx(xmin), cy(0.0));
		pDC->LineTo(cx(xmax), cy(0.0));
	}

}


// CMFC4View printing

BOOL CMFC4View::OnPreparePrinting(CPrintInfo* pInfo)
{
	// default preparation
	return DoPreparePrinting(pInfo);
}

void CMFC4View::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add extra initialization before printing
}

void CMFC4View::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add cleanup after printing
}


// CMFC4View diagnostics

#ifdef _DEBUG
void CMFC4View::AssertValid() const
{
	CView::AssertValid();
}

void CMFC4View::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}

CMFC4Doc* CMFC4View::GetDocument() const // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CMFC4Doc)));
	return (CMFC4Doc*)m_pDocument;
}
#endif //_DEBUG


// CMFC4View message handlers
